# multi_weight_reader.py (리스트 처리 최종 버전)
import time
import sys
import RPi.GPIO as GPIO
from hx711 import HX711
import json
import statistics # 리스트의 중간값을 계산하기 위해 추가

def cleanAndExit():
    """프로그램 종료 시 GPIO를 정리하는 함수"""
    GPIO.cleanup()
    sys.exit()

# --- 각 센서별 캘리브레이션 값을 순서대로 입력하세요! ---
OFFSETS = [359192.05, -33775.8, -55483.45]
SCALES = [14781.999999999998, 12990.471544715445, 14383.076612903225]

# --- GPIO 핀 설정 ---
SHARED_SCK_PIN = 6
DT_PINS = [5, 13, 19] # (센서1, 센서2, 센서3 순서)

results = {}
try:
    weights = []
    for i in range(len(DT_PINS)):
        hx = HX711(dout_pin=DT_PINS[i], pd_sck_pin=SHARED_SCK_PIN)
        
        # --- 수동 계산 (최종 수정 부분) ---
        # 1. 센서로부터 원시 데이터 리스트를 읽어옵니다.
        raw_data_list = hx.get_raw_data(times=5)
        
        # 2. 리스트의 중간값(median)을 사용하여 튀는 값을 제거합니다.
        if raw_data_list: # 리스트가 비어있지 않은지 확인
            raw_data = statistics.median(raw_data_list)
        else:
            raise RuntimeError("센서로부터 데이터를 읽어오지 못했습니다.")

        # 3. (중간값 - 영점) / 비율 공식을 직접 계산합니다.
        weight = (raw_data - OFFSETS[i]) / SCALES[i]
        
        weights.append(round(weight, 2))

    # 성공 시, 3개 센서의 값을 담은 객체 생성
    results = {
        "sensor_1": weights[0],
        "sensor_2": weights[1],
        "sensor_3": weights[2],
        "success": True
    }

except Exception as e:
    results = {"error": str(e), "success": False}

finally:
    # 성공하든 실패하든 항상 JSON 결과를 출력하고 종료
    print(json.dumps(results))
    cleanAndExit()
