// server.js (ìˆ˜ì •ëœ ì½”ë“œ)

const express = require('express');
const http = require('http');
const WebSocket = require('ws');
const mysql = require('mysql2/promise');
const bodyParser = require('body-parser');
const cors = require('cors');
const crypto = require('crypto');
const fetch = require('node-fetch');

const app = express();
app.use(cors());
app.use(bodyParser.json({ limit: '10mb' }));
app.use(bodyParser.urlencoded({ limit: '10mb', extended: true }));

// --- MariaDB ì—°ê²° ì„¤ì • ---
const pool = mysql.createPool({
    host: 'localhost',
    user: 'myuser', // â­ ì‹¤ì œ MariaDB ì‚¬ìš©ì ì´ë¦„ìœ¼ë¡œ ë³€ê²½í•˜ì„¸ìš”.
    password: 'mypassword', // â­ ì‹¤ì œ MariaDB ë¹„ë°€ë²ˆí˜¸ë¡œ ë³€ê²½í•˜ì„¸ìš”.
    database: 'myapp_db', // â­ ì‹¤ì œ ë°ì´í„°ë² ì´ìŠ¤ ì´ë¦„ìœ¼ë¡œ ë³€ê²½í•˜ì„¸ìš”.
    waitForConnections: true,
    connectionLimit: 10,
    queueLimit: 0
});

// DB ì—°ê²° í…ŒìŠ¤íŠ¸ ë° 'users' í…Œì´ë¸” ìƒì„±
(async () => {
    let connection;
    try {
        connection = await pool.getConnection();
        console.log('âœ… MariaDB ì—°ê²° í’€ ì„±ê³µì ìœ¼ë¡œ ê°€ì ¸ì˜´.');

        const createUsersTableSql = `
CREATE TABLE IF NOT EXISTS users (
    user_id INT AUTO_INCREMENT PRIMARY KEY,
    id VARCHAR(50) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    name VARCHAR(100) NOT NULL,
    phone VARCHAR(20),
    birth DATE,
    profile_image_base64 LONGTEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);`;
        await connection.execute(createUsersTableSql);
        console.log('âœ… \'users\' í…Œì´ë¸” ì¤€ë¹„ ì™„ë£Œ.');
        
        // â­ dose_history í…Œì´ë¸” ìƒì„± ì¿¼ë¦¬ ì¶”ê°€ â­
        const createDoseHistoryTableSql = `
CREATE TABLE IF NOT EXISTS dose_history (
    id INT AUTO_INCREMENT PRIMARY KEY,
    medicine_name VARCHAR(255) NOT NULL,
    date DATE NOT NULL,
    medicine_time TIME NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);`;
        await connection.execute(createDoseHistoryTableSql);
        console.log('âœ… \'dose_history\' í…Œì´ë¸” ì¤€ë¹„ ì™„ë£Œ.');

    } catch (err) {
        console.error('âŒ MariaDB ì—°ê²° ë˜ëŠ” í…Œì´ë¸” ìƒì„± ì‹¤íŒ¨:', err);
        process.exit(1);
    } finally {
        if (connection) connection.release();
    }
})();

// --- HTTP ë° WebSocket ì„œë²„ í†µí•© ì„¤ì • ---
const HTTP_PORT = 5000;
const WS_PORT = 3001;

// â­ Node-REDê°€ ì‹¤í–‰ ì¤‘ì¸ ë¼ì¦ˆë² ë¦¬ íŒŒì´ ë˜ëŠ” Node-RED ì„œë²„ì˜ IP ì£¼ì†Œ â­
const RASPBERRY_PI_IP = "192.168.0.7";

app.listen(HTTP_PORT, '0.0.0.0', () => {
    console.log(`ğŸš€ HTTP ì„œë²„ê°€ ${HTTP_PORT}ë²ˆ í¬íŠ¸ì—ì„œ ì‹¤í–‰ ì¤‘ì…ë‹ˆë‹¤.`);
});

const wss = new WebSocket.Server({ port: WS_PORT, path: '/ws' });

wss.on('listening', () => {
    console.log(`ğŸ“¡ WebSocket ì„œë²„ê°€ ${WS_PORT}ë²ˆ í¬íŠ¸ì—ì„œ ì‹¤í–‰ ì¤‘ì…ë‹ˆë‹¤. (ê²½ë¡œ: /ws)`);
});

const connectedClients = new Map();

function logConnectedClients() {
    console.log(`Current connected clients: ${connectedClients.size} users`);
    connectedClients.forEach((ws, userId) => {
        console.log(`   - User ID: ${userId}, WebSocket ReadyState: ${ws.readyState}`);
    });
}

wss.on('connection', ws => {
    console.log('Client connected to WebSocket.');

    ws.on('message', async message => {
        let parsedMessage;
        try {
            parsedMessage = JSON.parse(message.toString());
        } catch (e) {
            console.error('âŒ WebSocket ë©”ì‹œì§€ íŒŒì‹± ì˜¤ë¥˜:', e);
            return;
        }

        // 1. ì„¼ì„œ ë°ì´í„° ì²˜ë¦¬ ë¡œì§
        if (parsedMessage.temperature !== undefined && parsedMessage.humidity !== undefined) {
            parsedMessage.created_at = new Date().toISOString();
            
            wss.clients.forEach(client => {
                if (client.readyState === WebSocket.OPEN) {
                    client.send(JSON.stringify({ status: 'success', type: 'sensor_data', data: parsedMessage }));
                }
            });
            console.log('âœ… ì„¼ì„œ ë°ì´í„°ê°€ ëª¨ë“  ì—°ê²°ëœ í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ë¸Œë¡œë“œìºìŠ¤íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤.');

        }
        // 2. ì‚¬ìš©ì ID ë“±ë¡ ë©”ì‹œì§€ ì²˜ë¦¬
        else if (parsedMessage.type === 'register_user_ws_client' && parsedMessage.userId) {
            const userId = String(parsedMessage.userId);
            
            if (connectedClients.has(userId)) {
                const existingWs = connectedClients.get(userId);
                if (existingWs && existingWs !== ws && existingWs.readyState === WebSocket.OPEN) {
                    console.log(`ê²½ê³ : ê¸°ì¡´ ì‚¬ìš©ì '${userId}'ì˜ ì—°ê²°ì„ ë‹«ê³  ìƒˆë¡œìš´ ì—°ê²°ë¡œ ëŒ€ì²´í•©ë‹ˆë‹¤.`);
                    existingWs.close(1000, 'New connection established for the same user.');
                }
            }
            
            ws.userId = userId;
            connectedClients.set(userId, ws);
            console.log(`â­ ì‚¬ìš©ì '${userId}'ì˜ WebSocket í´ë¼ì´ì–¸íŠ¸ ë“±ë¡ë¨.`);
            logConnectedClients();
        }
        // â­ 3. Node-REDë¡œë¶€í„°ì˜ ì¬ê³  ì—…ë°ì´íŠ¸ í‘¸ì‹œ ë©”ì‹œì§€ ì²˜ë¦¬ â­
        else if (parsedMessage.type === 'stock_update_from_nodered' && parsedMessage.data) {
            console.log('ğŸ“¦ Node-REDë¡œë¶€í„° ì¬ê³  ì—…ë°ì´íŠ¸ í‘¸ì‹œ ìˆ˜ì‹ :', parsedMessage.data);
            const stockData = parsedMessage.data;

            wss.clients.forEach(client => {
                if (client.readyState === WebSocket.OPEN) {
                    client.send(JSON.stringify({
                        type: 'medicine_count_update_all_slots',
                        data: stockData
                    }));
                }
            });
            console.log('âœ… Node-REDì—ì„œ ë°›ì€ ì¬ê³  ë°ì´í„°ë¥¼ ëª¨ë“  ì—°ê²°ëœ ì•± í´ë¼ì´ì–¸íŠ¸ë¡œ ë¸Œë¡œë“œìºìŠ¤íŠ¸í–ˆìŠµë‹ˆë‹¤.');
        }
        // â­ 4. ì•±ì—ì„œ ë³´ë‚¸ 'ì”ì—¬ ê°œìˆ˜ ê³„ì‚° ëª…ë ¹' ì²˜ë¦¬ â­
        else if (parsedMessage.command === 'calculate_slot_counts') {
            console.log('ğŸ“¦ ì•±ìœ¼ë¡œë¶€í„° ì”ì—¬ ê°œìˆ˜ ê³„ì‚° ëª…ë ¹ ìˆ˜ì‹  (HTTP GET ë°©ì‹).');
            
            let actualCounts = [];
            try {
                // Node-REDì˜ HTTP ì—”ë“œí¬ì¸íŠ¸ëŠ” ì‹¤ì œ ì„¼ì„œ ë°ì´í„°ë¥¼ ì½ì–´ì˜¬ ê²ƒì…ë‹ˆë‹¤.
                const nodeRedUrl = `http://${RASPBERRY_PI_IP}:1880/get_medicine_counts`; // Node-REDì—ì„œ ì„¤ì •í•œ HTTP ì—”ë“œí¬ì¸íŠ¸
                console.log(`Node-RED ì—”ë“œí¬ì¸íŠ¸ í˜¸ì¶œ: ${nodeRedUrl}`);
                const response = await fetch(nodeRedUrl);
                
                if (!response.ok) {
                    throw new Error(`Node-RED ì‘ë‹µ ì˜¤ë¥˜: ${response.status} ${response.statusText}`);
                }
                actualCounts = await response.json();
                console.log('âœ… Node-REDë¡œë¶€í„° ì•½ ê°œìˆ˜ ë°ì´í„° ìˆ˜ì‹  (HTTP fetch):', actualCounts);

            } catch (error) {
                console.error('âŒ Node-REDë¡œë¶€í„° ì•½ ê°œìˆ˜ ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ ë°œìƒ (HTTP fetch):', error);
                // ì˜¤ë¥˜ ë°œìƒ ì‹œ ê¸°ë³¸ê°’ ë˜ëŠ” ì˜¤ë¥˜ ë©”ì‹œì§€ ì „ì†¡
                actualCounts = [
                    { slot: "ì¹¸1", count: 0 },
                    { slot: "ì¹¸2", count: 0 },
                    { slot: "ì¹¸3", count: 0 }
                ];
                if (ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'error',
                        message: `ì•½ ê°œìˆ˜ ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ${error.message}`
                    }));
                }
            }
            
            if (ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'medicine_count_update_all_slots',
                    data: actualCounts
                }));
                console.log('âœ… ì•½ ê°œìˆ˜ ë°ì´í„° ì•±ìœ¼ë¡œ ì „ì†¡ ì™„ë£Œ (HTTP fetch).');
            } else {
                console.warn('âš ï¸ ìš”ì²­í•œ í´ë¼ì´ì–¸íŠ¸ì˜ WebSocket ìƒíƒœê°€ OPENì´ ì•„ë‹ˆì–´ì„œ ì”ì—¬ ê°œìˆ˜ ë°ì´í„°ë¥¼ ì „ì†¡í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
            }
        }
        // 5. ì•Œë¦¼ í™•ì¸ ì‘ë‹µ ì²˜ë¦¬
        else if (parsedMessage.type === 'alarm_ack' && parsedMessage.alarmId && ws.userId) {
            console.log(`ğŸ”” ì‚¬ìš©ì '${ws.userId}'ë¡œë¶€í„° ì•Œë¦¼ ID '${parsedMessage.alarmId}' í™•ì¸ ì‘ë‹µ ìˆ˜ì‹ .`);
        }
        // 6. WebSocketì„ í†µí•´ 'alarm' íƒ€ì… ë©”ì‹œì§€ê°€ ìˆ˜ì‹ ëœ ê²½ìš°: ì‚¬ìš©ìë³„ ì•Œë¦¼ ë°œì†¡
        else if (parsedMessage.type === 'alarm' && parsedMessage.notificationTitle && parsedMessage.notificationMessage) {
            const { targetUserId, notificationTitle, notificationMessage } = parsedMessage;

            let notificationSent = false;
            
            if (targetUserId) {
                const client = connectedClients.get(String(targetUserId));
                if (client && client.readyState === WebSocket.OPEN) {
                    try {
                        client.send(JSON.stringify({
                            type: 'alarm',
                            notificationTitle: notificationTitle,
                            notificationMessage: notificationMessage,
                            timestamp: new Date().toISOString()
                        }));
                        notificationSent = true;
                        console.log(`âœ… ì‚¬ìš©ì '${targetUserId}'ì—ê²Œ ì•Œë¦¼ ì „ì†¡ ì„±ê³µ (WS-Alarm).`);
                    } catch (e) {
                        console.error(`âŒ ì‚¬ìš©ì '${targetUserId}'ì—ê²Œ ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨ (WS-Alarm):`, e);
                    }
                } else {
                    console.warn(`âš ï¸ ëŒ€ìƒ ì‚¬ìš©ì '${targetUserId}'ì˜ WebSocket í´ë¼ì´ì–¸íŠ¸ê°€ ì—°ê²°ë˜ì–´ ìˆì§€ ì•Šê±°ë‚˜, ìƒíƒœê°€ OPENì´ ì•„ë‹™ë‹ˆë‹¤.`);
                    logConnectedClients();
                }
            } 
            else {
                let clientsSentTo = 0;
                connectedClients.forEach((client, userId) => {
                    if (client.readyState === WebSocket.OPEN) {
                        try {
                            client.send(JSON.stringify({
                                type: 'alarm',
                                notificationTitle: notificationTitle,
                                notificationMessage: notificationMessage,
                                timestamp: new Date().toISOString()
                            }));
                            clientsSentTo++;
                        } catch (e) {
                            console.error(`âŒ ì‚¬ìš©ì '${userId}'ì—ê²Œ ì•Œë¦¼ ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨ (WS-Alarm ë¸Œë¡œë“œìºìŠ¤íŠ¸):`, e);
                        }
                    }
                });
                notificationSent = (clientsSentTo > 0);
                if (notificationSent) {
                    console.log(`âœ… ${clientsSentTo}ê°œì˜ ëª¨ë“  ë¡œê·¸ì¸ëœ í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ì•Œë¦¼ì´ ë¸Œë¡œë“œìºìŠ¤íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤ (WS-Alarm).`);
                } else {
                    console.warn('âš ï¸ ì•Œë¦¼ì„ ì „ì†¡í•  ìˆ˜ ìˆëŠ” í™œì„± ë¡œê·¸ì¸ëœ í´ë¼ì´ì–¸íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤ (WS-Alarm ë¸Œë¡œë“œìºìŠ¤íŠ¸).');
                    logConnectedClients();
                }
            }
        }
        // 7. ì•Œ ìˆ˜ ì—†ëŠ” ë©”ì‹œì§€ ì²˜ë¦¬
        else {
            console.warn('âš ï¸ ìˆ˜ì‹ ëœ WebSocket ë©”ì‹œì§€ê°€ ì²˜ë¦¬í•  ìˆ˜ ìˆëŠ” í˜•ì‹ì´ ì•„ë‹™ë‹ˆë‹¤:', parsedMessage);
        }
    });

    ws.on('close', () => {
        console.log('Client disconnected from WebSocket.');
        // ì—°ê²° ëŠê¹€ ì‹œ connectedClients Mapì—ì„œ í•´ë‹¹ WebSocket ì œê±° (userIdë¥¼ ì‚¬ìš©í•˜ì—¬)
        for (let [userId, clientWs] of connectedClients.entries()) {
            if (clientWs === ws) {
                connectedClients.delete(userId);
                console.log(`âŒ ì‚¬ìš©ì '${userId}'ì˜ WebSocket ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤.`);
                break;
            }
        }
        logConnectedClients();
    });

    ws.on('error', error => {
        console.error('WebSocket ì˜¤ë¥˜:', error);
    });
});

// --- HTTP API ì—”ë“œí¬ì¸íŠ¸ ì •ì˜ (íšŒì›ê°€ì…/ë¡œê·¸ì¸) ---

// 1. ì„œë²„ ìƒíƒœ í™•ì¸ì„ ìœ„í•œ ê¸°ë³¸ ë¼ìš°íŠ¸ (ê¸°ì¡´ ìœ ì§€)
app.get('/', (req, res) => {
    res.send('Node.js ì„œë²„ê°€ ì •ìƒì ìœ¼ë¡œ ì‹¤í–‰ ì¤‘ì…ë‹ˆë‹¤!');
});

// 2. íšŒì›ê°€ì… API (ê¸°ì¡´ ìœ ì§€)
app.post('/signup', async (req, res) => {
    const { id, password, name, phone, birth, profile_image_base64 } = req.body;
    if (!id || !password || !name) {
        return res.status(400).json({ status: 'fail', message: 'ì•„ì´ë””, ë¹„ë°€ë²ˆí˜¸, ì´ë¦„ì€ í•„ìˆ˜ ì…ë ¥ í•­ëª©ì…ë‹ˆë‹¤.' });
    }
    let connection;
    try {
        connection = await pool.getConnection();
        const [rows] = await connection.execute('SELECT id FROM users WHERE id = ?', [id]);
        if (rows.length > 0) {
            return res.status(409).json({ status: 'fail', message: 'ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ì•„ì´ë””ì…ë‹ˆë‹¤. ë‹¤ë¥¸ ì•„ì´ë””ë¥¼ ì‚¬ìš©í•´ì£¼ì„¸ìš”.' });
        }
        const password_hash = crypto.createHash('sha256').update(password).digest('hex');
        const sql = 'INSERT INTO users (id, password_hash, name, phone, birth, profile_image_base64) VALUES (?, ?, ?, ?, ?, ?)';
        const values = [id, password_hash, name, phone, birth, profile_image_base64];
        await connection.execute(sql, values);
        console.log(`íšŒì›ê°€ì… ì„±ê³µ: ì‚¬ìš©ì ID - ${id}`);
        res.status(201).json({ status: 'success', message: 'íšŒì›ê°€ì…ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!' });
    } catch (error) {
        console.error('íšŒì›ê°€ì… ì˜¤ë¥˜:', error);
        res.status(500).json({ status: 'error', message: 'íšŒì›ê°€ì… ì¤‘ ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.' });
    } finally {
        if (connection) connection.release();
    }
});

// 3. ë¡œê·¸ì¸ API (ê¸°ì¡´ ìœ ì§€)
app.post('/login', async (req, res) => {
    const { id, password } = req.body;
    if (!id || !password) {
        return res.status(400).json({ status: 'fail', message: 'ì•„ì´ë””ì™€ ë¹„ë°€ë²ˆí˜¸ë¥¼ ëª¨ë‘ ì…ë ¥í•´ì£¼ì„¸ìš”.' });
    }
    let connection;
    try {
        connection = await pool.getConnection();
        const [rows] = await connection.execute('SELECT user_id, id, password_hash FROM users WHERE id = ?', [id]);
        if (rows.length === 0) {
            return res.status(401).json({ status: 'fail', message: 'ì•„ì´ë”” ë˜ëŠ” ë¹„ë°€ë²ˆí˜¸ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.' });
        }
        const user = rows[0];
        const hashedPasswordAttempt = crypto.createHash('sha256').update(password).digest('hex');
        if (hashedPasswordAttempt === user.password_hash) {
            console.log(`ë¡œê·¸ì¸ ì„±ê³µ: ì‚¬ìš©ì ID - ${user.id}`);
            res.status(200).json({ status: 'success', message: 'ë¡œê·¸ì¸ ì„±ê³µ!', user_id: user.user_id, username: user.id });
        } else {
            res.status(401).json({ status: 'fail', message: 'ì•„ì´ë”” ë˜ëŠ” ë¹„ë°€ë²ˆí˜¸ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.' });
        }
    } catch (error) {
        console.error('ë¡œê·¸ì¸ ì˜¤ë¥˜:', error);
        res.status(500).json({ status: 'error', message: 'ë¡œê·¸ì¸ ì¤‘ ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.' });
    } finally {
        if (connection) connection.release();
    }
});

// â­ ë³µìš© ê¸°ë¡ì„ ê°€ì ¸ì˜¤ëŠ” API ì—”ë“œí¬ì¸íŠ¸ ì¶”ê°€ ë° ìˆ˜ì • â­
// ì•±ì—ì„œ ì´ HTTP ì—”ë“œí¬ì¸íŠ¸ë¥¼ í˜¸ì¶œí•˜ì—¬ ëª¨ë“  ë³µìš© ê¸°ë¡ì„ ê°€ì ¸ì˜µë‹ˆë‹¤.
app.get('/api/dosage-records', async (req, res) => {
    console.log('ğŸ“¦ /api/dosage-records ìš”ì²­ ìˆ˜ì‹  (ëª¨ë“  ë³µìš© ê¸°ë¡ ì¡°íšŒ).');
    let connection;
    try {
        connection = await pool.getConnection();
        // dateì™€ medicine_timeë§Œ ì„ íƒí•˜ê³ , ë‚ ì§œì™€ ì‹œê°„ ìˆœìœ¼ë¡œ ì •ë ¬í•©ë‹ˆë‹¤.
        const [rows] = await connection.execute(
            'SELECT date, medicine_time FROM dose_history ORDER BY date ASC, medicine_time ASC;'
        );

        const formattedRecords = rows.map(record => {
            // MySQLì—ì„œ Dateì™€ Time íƒ€ì…ì´ Node.jsë¡œ ë„˜ì–´ì˜¬ ë•Œ Date ê°ì²´ë¡œ ë³€í™˜ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
            // .toISOString().slice()ë¥¼ ì‚¬ìš©í•˜ì—¬ YYYY-MM-DDì™€ HH:MM:SS ë¶€ë¶„ì„ ì¶”ì¶œí•˜ì—¬ ì¡°í•©í•©ë‹ˆë‹¤.
            const datePart = record.date instanceof Date ? record.date.toISOString().slice(0, 10) : record.date;
            const timePart = record.medicine_time instanceof Date ? record.medicine_time.toISOString().slice(11, 19) : record.medicine_time;

            const combinedDateTimeString = `${datePart}T${timePart}`;
            const dosageDateTime = new Date(combinedDateTimeString); // Date ê°ì²´ ìƒì„±

            return {
                dosageDateTime: dosageDateTime.toISOString() // ì•±ì´ íŒŒì‹±í•  ìˆ˜ ìˆëŠ” ISO 8601 ë¬¸ìì—´
            };
        });

        console.log(`âœ… ${formattedRecords.length}ê°œì˜ ë³µìš© ê¸°ë¡ì„ ì„±ê³µì ìœ¼ë¡œ ì¡°íšŒí–ˆìŠµë‹ˆë‹¤.`);
        res.json({
            status: 'success',
            message: 'All dosage records fetched successfully',
            data: formattedRecords
        });

    } catch (error) {
        console.error('âŒ ëª¨ë“  ë³µìš© ê¸°ë¡ì„ ê°€ì ¸ì˜¤ëŠ” ì¤‘ ë°ì´í„°ë² ì´ìŠ¤ ì˜¤ë¥˜ ë°œìƒ:', error);
        res.status(500).json({ status: 'error', message: 'ëª¨ë“  ë³µìš© ê¸°ë¡ì„ ê°€ì ¸ì˜¤ëŠ” ì¤‘ ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.' });
    } finally {
        if (connection) connection.release();
    }
});

// --- 404 Not Found í•¸ë“¤ëŸ¬ ---
app.use((req, res, next) => {
    console.log(`ğŸ¤·â€â™‚ï¸ ì •ì˜ë˜ì§€ ì•Šì€ ìš”ì²­: ${req.method} ${req.originalUrl}`);
    res.status(404).send(`ìš”ì²­í•˜ì‹  ê²½ë¡œ (${req.originalUrl})ë¥¼ ì°¾ì„ ìˆ˜ ì—†ê±°ë‚˜ ì§€ì›í•˜ì§€ ì•ŠëŠ” HTTP ë©”ì„œë“œ (${req.method})ì…ë‹ˆë‹¤.`);
});