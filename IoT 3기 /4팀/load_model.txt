# load_model.py
# -*- coding: utf-8 -*-
"""
Model loader & predictor (schema-compatible with deployed pickle)

- Supports both AMF as a list of MondrianTreeRegressor (preferred) and a single estimator.
- No learning during prediction (transform_only).
- Safely aliases "order" -> "복용순서" if needed.
"""

import pickle
from types import SimpleNamespace
from typing import Any, Dict, Optional

class NextDoseModel:
    def __init__(self, model_path: str):
        with open(model_path, "rb") as f:
            obj = pickle.load(f)
        # Allow dict payloads (recommended) or direct object
        self.p = SimpleNamespace(**obj) if isinstance(obj, dict) else obj

    # --- utilities -----------------------------------------------------------
    @staticmethod
    def _ensure_alias(feats: Dict[str, Any]) -> Dict[str, Any]:
        # Match training feature column name
        if "복용순서" not in feats and "order" in feats:
            feats = dict(feats)
            feats["복용순서"] = feats["order"]
        return feats

    def _transform(self, feats: Dict[str, Any]):
        x = self._ensure_alias(feats)
        return self.p.onehot.transform_one(x)

    def _predict_amf(self, x_enc) -> Optional[float]:
        amf = getattr(self.p, "amf", None)
        if amf is None:
            return None
        # Schema 1: list of trees (preferred in current deployment)
        if isinstance(amf, list):
            preds = [t.predict_one(x_enc) for t in amf]
            preds = [p for p in preds if p is not None]
            return (sum(preds) / len(preds)) if preds else None
        # Schema 2: single estimator (e.g., AMFRegressor)
        return amf.predict_one(x_enc)

    # --- public API ----------------------------------------------------------
    def predict_minutes(self, feats: Dict[str, Any], debug: bool=False) -> Optional[float]:
        x_enc = self._transform(feats)  # transform only; do NOT learn during inference

        p_dev = self._predict_amf(x_enc)

        if getattr(self.p, "use_ensemble", False) and getattr(self.p, "lin", None) is not None:
            p_lin = self.p.lin.predict_one(x_enc)
            if p_lin is not None and p_dev is not None:
                p_dev = 0.5 * (p_dev + p_lin)
            elif p_lin is not None:
                p_dev = p_lin

        if p_dev is None:
            return None

        minutes = 1440.0 + float(p_dev)
        if debug:
            try:
                import logging
                logging.getLogger("nextdose.model").info("dev=%.3f, minutes=%.2f", float(p_dev), minutes)
            except Exception:
                pass
        return minutes


def next_time_from(now_dt, minutes: float) -> str:
    import pandas as pd
    return (now_dt + pd.to_timedelta(float(minutes), unit="m")).strftime("%Y-%m-%d %H:%M")
