# -*- coding: utf-8 -*-
"""
Raspberry Pi 5 + rpicam-vid(MJPEG stdout) + OpenCV + face_recognition + MQTT (JSON)
- 파이 3.9 venvOK (picamera2 필요 없음)
- HDMI 화면에 얼굴 박스/이름/일치율(Unknown 포함) 표시
- 일치율 55% 이상일 때 '사람당 1회만' MQTT JSON 발행
"""

import os, time, json, signal, subprocess, threading
import numpy as np
import cv2
import face_recognition
import paho.mqtt.client as mqtt
from paho.mqtt.client import CallbackAPIVersion

# ===== 설정 =====
ENCODING_DIR = "/home/pi5/face_project/encodings"
SCALE = 0.5
MATCH_TOLERANCE = 0.6
CONF_THRESHOLD  = 55.0          # 55% 이상일 때만 발행(사람당 1회)
LOST_TIMEOUT    = 1.5

WIDTH, HEIGHT, FPS = 1280, 720, 15
RPICAM_CMD = [
    "rpicam-vid", "--nopreview", "--codec", "mjpeg",
    "--width", str(WIDTH), "--height", str(HEIGHT),
    "--framerate", str(FPS), "-t", "0", "-o", "-"
]

SHOW_WINDOW = True
WINDOW_NAME = "FaceCam"
SHOW_UNKNOWN_CONF = True
DEBUG_SCORE_LOG   = True

MQTT_BROKER = "localhost"      # 외부 브로커면 IP로 변경
MQTT_PORT   = 1883
MQTT_TOPIC  = "face_recognition/detected"
# ============

def clamp(v, a, b): return a if v < a else b if v > b else v

def load_known_encodings(d):
    if not os.path.isdir(d):
        raise FileNotFoundError(f"Encoding dir not found: {d}")
    names, encs = [], []
    for f in sorted(os.listdir(d)):
        if f.endswith(".npy"):
            name = f[:-4]
            enc  = np.load(os.path.join(d, f))
            if enc is None or enc.size == 0: continue
            names.append(name); encs.append(enc.reshape(-1))
    return names, encs

# MQTT
_connected = threading.Event()
def on_connect(client, userdata, flags, reason_code, properties=None):
    print(f"[MQTT] on_connect rc={reason_code}")
    if reason_code == 0: _connected.set()

def make_mqtt():
    client = mqtt.Client(client_id="pi5-face",
                         protocol=mqtt.MQTTv5,
                         callback_api_version=CallbackAPIVersion.VERSION2)
    client.on_connect = on_connect
    client.will_set(MQTT_TOPIC, payload=json.dumps({"end": True}, ensure_ascii=False), qos=0, retain=False)
    client.connect(MQTT_BROKER, MQTT_PORT, 60)
    client.loop_start()
    _connected.wait(3)
    return client

def mqtt_pub(client, payload: dict):
    msg = json.dumps(payload, ensure_ascii=False)
    print("[MQTT-PUB]", msg)
    rc, _ = client.publish(MQTT_TOPIC, msg, qos=0, retain=False)
    if rc != mqtt.MQTT_ERR_SUCCESS:
        print(f"[MQTT] publish failed rc={rc}: {msg}")

# MJPEG 프레임 제너레이터
def mjpeg_frames(cmd):
    proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize=0)

    def _stderr_reader():
        for line in iter(proc.stderr.readline, b""):
            s = line.decode("utf-8", "ignore").rstrip()
            if s: print(f"[rpicam-vid] {s}")
    threading.Thread(target=_stderr_reader, daemon=True).start()

    buf = bytearray()
    SOI, EOI = b"\xff\xd8", b"\xff\xd9"
    try:
        while True:
            chunk = proc.stdout.read(65536)
            if not chunk: break
            buf.extend(chunk)
            while True:
                s = buf.find(SOI)
                if s == -1:
                    if len(buf) > 2*1024*1024: del buf[:-2048]
                    break
                e = buf.find(EOI, s+2)
                if e == -1:
                    if len(buf) > 8*1024*1024: del buf[:s]
                    break
                jpg = bytes(buf[s:e+2])
                del buf[:e+2]
                yield jpg
    finally:
        try: proc.terminate()
        except: pass
        try: print(f"[rpicam-vid] exited rc={proc.wait(timeout=1)}")
        except: pass

def main():
    names, encs = load_known_encodings(ENCODING_DIR)
    print(f"[INFO] encodings loaded: {len(encs)}")

    client = make_mqtt()
    mqtt_pub(client, {"boot": True, "timestamp": int(time.time())})

    last_seen = {}
    sent_flags = {}     # 한 번 발행한 이름 기록 (세션 동안 유지)
    running = True
    def stop(sig, frm):
        nonlocal running; running = False
    signal.signal(signal.SIGINT, stop)
    signal.signal(signal.SIGTERM, stop)

    gen = mjpeg_frames(RPICAM_CMD)
    got_any = False
    can_show = SHOW_WINDOW

    try:
        for jpg in gen:
            if not running: break
            if not got_any:
                got_any = True
                print("[INFO] first MJPEG frame received")

            arr = np.frombuffer(jpg, dtype=np.uint8)
            frame = cv2.imdecode(arr, cv2.IMREAD_COLOR)
            if frame is None: continue

            now = time.time()
            small = cv2.resize(frame, (0,0), fx=SCALE, fy=SCALE) if SCALE != 1.0 else frame
            rgb_small = cv2.cvtColor(small, cv2.COLOR_BGR2RGB)

            locs = face_recognition.face_locations(rgb_small, model="hog", number_of_times_to_upsample=1)
            face_vecs = face_recognition.face_encodings(rgb_small, locs)

            current = set()
            draw_items = []
            scale_up = int(1.0 / SCALE) if SCALE != 0 else 1

            for enc, (top, right, bottom, left) in zip(face_vecs, locs):
                if not encs:
                    name, conf, best_dist = "Unknown", 0.0, 1.0
                else:
                    dists = face_recognition.face_distance(encs, enc)
                    best_i = int(np.argmin(dists))
                    best_dist = float(dists[best_i])
                    conf = round(clamp(1.0 - best_dist, 0.0, 1.0) * 100.0, 2)
                    name = "Unknown"
                    if best_dist < MATCH_TOLERANCE:
                        name = names[best_i]
                        current.add(name)
                        last_seen[name] = now
                        # 55% 이상 & 아직 한 번도 안 보낸 경우만 발행
                        if conf >= CONF_THRESHOLD and not sent_flags.get(name, False):
                            mqtt_pub(client, {"name": name, "confidence": float(conf), "timestamp": int(now)})
                            sent_flags[name] = True

                if DEBUG_SCORE_LOG:
                    print(f"[DBG] dist={best_dist:.3f}, conf={conf:5.1f}%, name={name}")

                if SHOW_UNKNOWN_CONF or name != "Unknown":
                    T, R, B, L = top*scale_up, right*scale_up, bottom*scale_up, left*scale_up
                    draw_items.append((T, R, B, L, f"{name} {conf:.0f}%"))

            # 사라짐 이벤트(발행은 하지만 sent_flags는 유지 → 1회 규칙 유지)
            for n in list(last_seen.keys()):
                if n not in current and (now - last_seen[n]) > LOST_TIMEOUT:
                    mqtt_pub(client, {"name": n, "confidence": 0.0, "timestamp": int(now), "lost": True})
                    last_seen.pop(n, None)
                    # sent_flags.pop(n, None)  # 지우지 않음: 세션 동안 1회만

            # 화면 표시
            if can_show:
                disp = frame.copy()
                for (T, R, B, L, label) in draw_items:
                    cv2.rectangle(disp, (L, T), (R, B), (0, 255, 0), 2)
                    (tw, th), _ = cv2.getTextSize(label, cv2.FONT_HERSHEY_SIMPLEX, 0.6, 2)
                    y1 = max(0, T - th - 8)
                    cv2.rectangle(disp, (L, y1), (L + tw + 6, y1 + th + 6), (0, 255, 0), -1)
                    cv2.putText(disp, label, (L + 3, y1 + th), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0,0,0), 2)
                try:
                    cv2.imshow(WINDOW_NAME, disp)
                    key = cv2.waitKey(1) & 0xFF
                    if key in (27, ord('q')): break
                except Exception as e:
                    print(f"[WARN] imshow failed; disabling window: {e}")
                    can_show = False

    except Exception as e:
        mqtt_pub(client, {"error": str(e), "timestamp": int(time.time())})
        raise
    finally:
        mqtt_pub(client, {"end": True, "timestamp": int(time.time())})
        try:
            if can_show: cv2.destroyAllWindows()
        except: pass
        client.loop_stop(); client.disconnect()
        print("[INFO] stopped cleanly.")

if __name__ == "__main__":
    main()
